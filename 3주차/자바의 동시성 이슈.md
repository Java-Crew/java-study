자바에서 동시성(공유자원 접근)으로 인해 발생할 수 있는 문제점과 이를 해결할 수 있는 방법에 대해 살펴보려 한다.

# 동시성 프로그래밍에서 발생할 수 있는 문제점

컴퓨터의 `CPU`와 `RAM`의 관계도를 그려보면 다음과 같은 그림이 될 것이다. 설명의 편의를 위해 최대한 간단한 예로 들겠다.

![image](https://user-images.githubusercontent.com/55661631/147545948-2b9119ad-4afb-4385-9c09-03d71129add3.png)

`CPU`가 어떤 작업을 처리하기 위해 데이터가 필요할 때, `CPU`는 `RAM`의 일부분을 고속의 저장 장치인 `CPU Cache Memory`로 읽어들인다. 이 읽어들인 데이터로 명령을 수행하고 이 데이터를 다시 `RAM`에 저장하기 위해서는 데이터를 읽어들일 때의 과정을 역순으로 밟는다. 즉, 적절한 시점에 `CPU Cache Memory`에서 `RAM`으로 쓰기 작업을 하게 된다. 그러나 `CPU`가 캐시에 쓰기 작업을 수행했다고 해서 바로 `RAM`으로 쓰기 작업을 수행하지 않는다. 반대의 과정인 읽기 작업도 마찬가지이다.

동시성 프로그래밍에서는 `CPU`와 `RAM`의 중간에 위치하는 `CPU Cache Memory`와 병렬성이라는 특징 때문에 다수의 스레드가 공유 자원에 접근할 때 **두 가지 문제**가 발생할 수 있다. 

- 가시성 문제
- 원자성(동시 접근) 문제

사실 위의 두 문제는 동시성보다는 병렬성 때문에 발생하는 문제이지만, **자바 스레드는 동시성의 성질을 가지고 있으므로, 자바에서는 동시성 프로그래밍에서 발생하는 문제점**이라고 부르는듯 하다.

# 가시성 문제

위에서 말했듯이 가시성 문제는 여러 개의 스레드가 사용됨에 따라, `CPU Cache Memory`와 `RAM`의 데이터가 서로 일치하지 않아 생기는 문제를 의미한다.

이를 해결하기 위해서는 **가시성이 보장**되어야 하는 변수들을  `CPU Cache Memory`에서 불러오는 것이 아닌 `RAM`에서 바로 읽도록 보장해야 한다.

**변수에 `volatile` 키워드를 붙여줘서 가시성을 보장할 수 있다.**

```java
private static volatile boolean isStop;
```

`volatile`에 관련된 자세한 내용은 따로 다루도록 하겠다. [링크](https://www.notion.so/volatile-34f076bdeb254edaa8178cc476468562)

**그러나 가시성만 보장된다고 동시성이 보장되는 것이 아니다. 간단한 예를 살펴보자.**

전철 비용을 계산하는 프로그램을 짠다고 가정하겠다. 이 때 나이에 따라서 70세 미만과 70세 이상의 표 값이 다른 상황이고, 날짜를 실시간으로 반영하여 비용을 계산해야 한다.

각 스레드의 역할은 다음과 같다.

- Thread 1
    - 고객의 나이를 읽는다.
    - 읽어온 나이를 기준으로 비용을 계산한다.
    - 비용을 반환한다.
- Thread 2
    - 현재 년도를 지속적으로 읽는다.
    - 해가 바뀌면 고객의 나이를 계산한다.
    - 바뀐 고객의 나이를 저장한다.
    

`volatile`을 통해 가시성을 해결했지만, 해가 바뀌는 시점에 문제가 발생한다.

1. 나이가 69살인 고객이 계산을 진행할 때, 첫 번째 스레드에서는 `RAM`에서 나이가 69세임을 가져와 나이에 따라 비용을 계산하는 메소드를 실행한다. 
2. 그러나 마침 해가 딱 바뀌어 년 바뀜을 계산하는 두 번째 스레드에서 `RAM`에 해당 고객의 나이를 70살로 수정한다.
3. 첫 번째 스레드는 나이가 70살로 바뀐 것을 모르고 69살로 계산하여 전철 비용을 계산해서 잘못된 비용을 반환한다.

**이렇게 가시성이 보장된다고 동시성이 보장되는 것은 아니다.** 그러나 `volatile` 만으로 동시성이 보장되는 경우도 있는데, 이러한 경우는 `하나의 스레드만이 연산을 해야 한다`라는 전제가 깔려있다. 이 전제가 확실한 경우 `lock`없이 `volatile`만으로도 문제 없는 데이터를 사용할 수 있다.

# 원자성 문제

원자성은 가시성과 멀티 스레드 환경에서 스레드간 공유 메모리 이슈를 발생시킨다는 점에 공통점을 가지고 있다. 하지만 시스템 관점에서 보면 두 개념은 다른 곳에 존재한다.

- 가시성
    - `CPU` - `Cache` - `Memory` 관계 상의 개념
- 원자성
    - 한줄의 프로그램 문장이 컴파일러에 의해 기계어로 변경되면서, 이를 기계가 순차적으로 처리하기 위한 여러 개의 `Machine Instruction`이 만들어져 실행되기 때문에 일어나는 현상을 설명하는 용어

원자성이라는 단어는 상당히 은유적이다. 연산의 원자성이라고 하면 좀더 이해가 쉽다. 관련 도서나 자료에서는 이를 연산의 단일성 혹은 단일 연산이라고 부르기도 한다. 

쉽게 설명하자면 공유되는 변수를 변경할 때 기존의 값을 기반으로 새로운 값이 결정되는 과정에서 여러 스레드가 이를 동시에 수행할 때 생기는 이슈이다.

예를 들어, `i++` 연산을 2개의 스레드가 동시에 100회 실행한다고 가정해보자. 만약 `i++` 연산이 원자성을 가지고 있는 연산이라고 하면 결과가 200이여야 하겠지만, 실제로 프로그램을 수행하면 200보다 작은 값이 출력된다. 이런 결과의 원인은 `i++`가 3개의 instruction으로 이루어져 있기 때문에 스레드 A가 i값을 읽어 `i+1` 연산을 해서 메모리에 반영하기 직전에 스레드 B가 `i+1` 연산을 수행하고 메모리에 반영을 한다면 후자의 연산은 무효가 되기 때문이다.

이러한 원자성 문제를 해결하기 위해서는 `synchronized` 또는 `atomic`을 사용해야 한다.

**참고로 원자성 문제를 `synchronized` 또는 `atomic`을 통해 해결한다면 가시성의 문제도 해결된다.** `synchronized` 블럭을 들어가기 전에 `CPU Cache Memory`와 `Main Memory`를 동기화 해주며, `atomic`의 경우에는 CAS 알고리즘에 의해 원자성 문제와 `CPU Cache Memory`에 잘못된 값을 참조하는 문제를 동시에 해결해주기 때문이다.

## synchronized (blocking)

`synchronized`는 멀티 스레드 환경에서 동시성 제어를 위해 **공유 객체를 동기화**하는 키워드이다. `synchronized` 블록 안에서 관리되는 자원들은 원자성을 보장할 수 있다.

자세한 내용은 따로 다루도록 하겠다. [링크](https://www.notion.so/synchronized-27ac554a2f094eef8c2fc3a900ee095a)

## atomic (non-blocking)

`atomic` 또한 멀티 스레드 환경에서 원자성을 보장하기 위해 나온 개념이다. 동기화(blocking)가 아닌 CAS(Compared And Swap)라는 알고리즘으로 작동하여 원자성을 보장한다.

> **CAS 알고리즘이란**
`volatile`에서 설명했던 `CPU Cache Memory`와 `RAM`을 비교하여 일치한다면 `CPU Cache Memory`와 `RAM`에 적용하고, 일치하지 않는다면 재시도 하여 어떠한 쓰레드에서 공유 자원에 읽기/쓰기 작업을 하더라도 원자성을 보장한다.
> 

대표적인 예로 자바의 `Concurrent` 패키지의 타입들은 CAS 알고리즘을 이용해 원자성을 보장한다. 자세한 내용은 따로 다루도록 하겠다.

# 참고

- [https://ecsimsw.tistory.com/entry/자바의-동기화-방식-메모리-가시성이란-synchronized-volatile-atomic](https://ecsimsw.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%9D%98-%EB%8F%99%EA%B8%B0%ED%99%94-%EB%B0%A9%EC%8B%9D-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%80%EC%8B%9C%EC%84%B1%EC%9D%B4%EB%9E%80-synchronized-volatile-atomic)
- [https://badcandy.github.io/2019/01/14/concurrency-02/](https://badcandy.github.io/2019/01/14/concurrency-02/)
- [https://medium.com/thxwelchs/동시성-프로그래밍-2편-멀티쓰레드-객체공유와-상태제어-44e9f697c3d9](https://medium.com/thxwelchs/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-2%ED%8E%B8-%EB%A9%80%ED%8B%B0%EC%93%B0%EB%A0%88%EB%93%9C-%EA%B0%9D%EC%B2%B4%EA%B3%B5%EC%9C%A0%EC%99%80-%EC%83%81%ED%83%9C%EC%A0%9C%EC%96%B4-44e9f697c3d9)
- [https://velog.io/@syleemk/Java-Concurrent-Programming-가시성과-원자성](https://velog.io/@syleemk/Java-Concurrent-Programming-%EA%B0%80%EC%8B%9C%EC%84%B1%EA%B3%BC-%EC%9B%90%EC%9E%90%EC%84%B1)

# 예상 면접 질문 및 답변

### Q. 동시성 프로그래밍에서 발생할 수 있는 문제는?

동시성 프로그램에서는 `CPU`와 `RAM`의 중간에 위치하는 `CPU Cache Memory`와 병렬성이라는 특징 때문에 가시성 문제, 원자성 문제가 발생할 수 있습니다.

### Q. 가시성 문제과 원자성 문제에 대해 설명

- 가시성 문제
    - 여러 개의 스레드가 사용됨에 따라, `CPU Cache Memory`와 `RAM`의 데이터가 서로 일치하지 않아 생기는 문제를 의미한다. 가시성을 보장되어야 하는 변수에 `volatile` 키워드를 붙여줘서 `RAM`에서 바로 읽도록 해야한다. 그러나 여러 스레드가 공유 자원에 쓰기 연산을 할 경우 가시성을 보장했다고 동시성이 보장되지 않는다.
- 원자성 문제
    - 여러 스레드가 공유 자원에 동시에 쓰기 연산을 할 경우 잘못된 결과를 반환하는 것을 의미한다. 따라서 `synchronized`, `atomic` 통해 원자성을 보장해야 한다.
