## HashTable이란?

![image](https://user-images.githubusercontent.com/55661631/156127497-871833e9-cb07-4c38-9ede-9907214e14f4.png)

### 정의

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조이다. 해시 테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열을 사용하여 데이터를 저장하기 때문이다.

해시 테이블은 각각의 Key값에 해시 함수를 적용해 배열의 고유한 인덱스를 생성하고, 이 인덱스를 활용해 값을 저장하거나 검색하게 된다. 인덱스를 활용해 값을 저장하거나 검색하게 된다. 여기서 실제 값이 저장되는 장소를 **버킷** 또는 **슬롯**이라고 한다.

### 해시 함수(Hash Function)

해시 함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것이다. 해시 테이블에 사용되는 대표적인 해시 함수로는 아래의 3가지가 있다.

1. Division Method: 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다.( 주소 = 입력값 % 테이블의 크기) 테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.
2. Digit Folding: 각 Key의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법이다.
3. Multiplication Method: 숫자로 된 Key값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 해준다. h(k)=(kAmod1) × m
4. Univeral Hashing: 다수의 해시함수를 만들어 집합 H에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만드는 기법이다.

### 동작 과정

Key, Value가 "John Smith", "521-1234"인 데이터를 크기가 16인 해시 테이블에 저장한다고 가정하자.  

1. index = hash_function("John Smith") % 16 연산을 통해 인덱스 값을 계산한다. 
2. 그리고 array[index] = "521-1234" 로 전화번호를 저장하게 된다.

이러한 해싱 구조로 데이터를 저장하면 Key값으로 데이터를 찾을 때 해시 함수를 1번만 수행하면 되므로 매우 빠르게 데이터를 저장/삭제/조회할 수 있다.

**따라서 해시 테이블의 평균 시간복잡도는 O(1)이다.**

## 해시 충돌

만약 A, B Key를 해시 함수를 돌려 나온 값이 동일할 수도 있는데, 이런 현상을 해시 충돌이라고 한다.

해시 테이블에서는 충돌에 의한 문제를 **분리 연결법**과 **개방 주소법**으로 크게 2가지로 해결하고 있다.

### 분리 주소법(Separate Chaining)

![image](https://user-images.githubusercontent.com/55661631/156127542-01702b02-fda4-46a6-80fe-36a1a74896ce.png)

개방 주소법은 버킷에서 충돌이 일어나면 기존 값과 새로운 값을 연결 리스트로 연결하는 방법이다.

**장점**

- 간단하게 구현이 가능하고, 손쉽게 삭제할 수 있다.
- 해시 테이블 확장이 필요없다. 충돌이 나면 그때 공간을 만들어서 연결만 해주면 된다.

**단점**

- 데이터의 수가 많아지면 동일한 버킷에 연결되는 데이터가 많아지며 그에 따라 검색의 속도가 느려진다.

### 개방 주소법(Open Address)

개방 주소법이란 추가적인 메모리를 사용하는 Chaining 방식과 다르게 비어있는 해시 테이블의 공간을 활용하는 방법이다. 

개방 주소법을 구현하기 위한 대표적인 방법으로는 3가지 방식이 존재한다.

- Linear Probing
    - 현재의 버킷 인덱스로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.
- Quadratic Probing
    - 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.
- Double Hashing Probing
    - 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.
    
![image](https://user-images.githubusercontent.com/55661631/156127582-6c42aa17-7cc7-425a-8bab-c8573cce3ac9.png)

## 해시 테이블 시간 복잡도

- 각각의 Key값은 해시함수에 의해 고유한 인덱스를 가지게 되어 바로 접근할 수 있으므로 평균 **O(1)**의 시간복잡도로 데이터를 조회할 수 있다.
- 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야 하므로 **O(N)**까지 시간복잡도가 증가할 수 있다.

## Java의 HashTable과 HashMap

- HashTable은 JDK 1.0부터 있던 Java의 API이고, HashMap은 Java 2에서 처음 선보인 JCF(Java Collections Framework)에 속한 API이다.
- HashTable 또한 Map 인터페이스를 구현하고 있기때문에 HashMap과 HashTable이 제공하는 기능은 같다.

**차이점**

- 보조 해시 함수
    - HashMap은 보조 해시 함수를 사용하기 때문에 보조 해시 함수를 사용하지 않는 HashTable에 비하여 해시 충돌이 덜 발생할 수 있어 상대적으로 성능상 이점이 있다.
- 동기화
    - HashTable은 `synchronized` 메소드를 사용해 동기화를 지원하는 반면에, HashMap은 동기화를 지원하지 않는다.

## 참고

- [https://mangkyu.tistory.com/102](https://mangkyu.tistory.com/102)
- [https://bcho.tistory.com/1072](https://bcho.tistory.com/1072)
- [https://go-coding.tistory.com/30](https://go-coding.tistory.com/30)
